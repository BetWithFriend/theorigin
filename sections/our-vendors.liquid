{{ 'our-vendors.css' | asset_url | stylesheet_tag }}
<div class="our-vendors-wrapper" data-section-id="{{ section.id }}">
    <div class="our-vendors-logo-wrapper">
        {% for vendor in shop.metaobjects.vendor_definitions.values %}
            <div class="our-vendor-container">
                <div onclick="goToVendorPage({{ vendor.vendor_name.value | json | escape }})" class="our-vendor-logo">
                    <img
                        class="our-vendor-logo-img"
                        src="{{ vendor.vendor_logo | image_url: width: 100 }}"
                        alt="Vendor Logo"
                        width="100"
                        height="100"
                        loading="lazy"
                        decoding="async"
                    >
                </div>
                <!--<div class="vendors-collection-vendor-description-wrapper">
                    <div class="vendors-collection-vendor-name">{{ vendor.vendor_name }}</div>
                </div>-->
            </div>
        {% endfor %}
    </div>

    {%- comment -%}
      Mobile-only rotator (progressive enhancement):
      - No-JS: the `.our-vendors-logo-wrapper` stays visible.
      - JS-enabled (mobile): we add `.our-vendors--enhanced` and render 3-at-a-time here.
    {%- endcomment -%}
    <div class="our-vendors-rotator" aria-hidden="true">
        <div class="our-vendors-rotator__row" data-our-vendors-rotator-row>
            {% for i in (1..3) %}
                <button type="button" class="our-vendor-logo our-vendors-rotator__slot" data-our-vendors-slot="{{ i }}">
                    <img class="our-vendor-logo-img" alt="Vendor Logo" width="100" height="100" loading="eager" decoding="async">
                </button>
            {% endfor %}
        </div>
    </div>

    {% render 'single-quote', desktop_only: true %}
</div>

<script type="application/json" id="OurVendorsData-{{ section.id }}">
[
    {%- for vendor in shop.metaobjects.vendor_definitions.values -%}
        {
            "name": {{ vendor.vendor_name.value | json }},
            "logo": {{ vendor.vendor_logo | image_url: width: 100 | json }}
        }{%- unless forloop.last -%},{%- endunless -%}
    {%- endfor -%}
]
</script>

<script>
    function goToVendorPage(vendorName) {
        window.location.href = "{{ section.settings.collection.url }}/pages/vendor-" + vendorName.replaceAll(' ', '-');
    }

    (function initOurVendorsRotator() {
        const wrapper = document.querySelector('.our-vendors-wrapper[data-section-id="{{ section.id }}"]');
        if (!wrapper) return;
        if (wrapper.dataset.ourVendorsInit === '1') return;
        wrapper.dataset.ourVendorsInit = '1';

        const dataEl = document.getElementById('OurVendorsData-{{ section.id }}');
        if (!dataEl) return;

        let vendors = [];
        try {
            vendors = JSON.parse(dataEl.textContent || '[]');
        } catch (e) {
            return;
        }

        const rotator = wrapper.querySelector('.our-vendors-rotator');
        const row = wrapper.querySelector('[data-our-vendors-rotator-row]');
        const slots = Array.from(wrapper.querySelectorAll('[data-our-vendors-slot]'));
        const imgs = slots.map((slot) => slot.querySelector('img'));
        const batchSize = 3;
        const intervalMs = 3000;
        const fadeMs = 600;

        if (!rotator || !row || slots.length !== batchSize || vendors.length === 0) return;

        // Only enhance on mobile (match CSS breakpoint).
        const mobileMql = window.matchMedia('(max-width: 768px)');

        // If fewer than 3 vendors, just render what we have and don't animate.
        const effectiveBatchSize = Math.min(batchSize, vendors.length);

        const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;
        const fadeDuration = prefersReducedMotion ? 0 : fadeMs;

        let startIndex = 0;
        let timerId = null;
        let inTick = false;
        let inView = true;
        let tickToken = 0;
        let uiEnabled = false;

        const preloadCache = new Map(); // src -> Promise<void>

        function preloadSrc(src) {
            if (!src) return Promise.resolve();
            if (preloadCache.has(src)) return preloadCache.get(src);

            const p = new Promise((resolve) => {
                const img = new Image();
                img.decoding = 'async';
                img.onload = () => resolve();
                img.onerror = () => resolve();
                img.src = src;
                if (img.decode) {
                    img.decode().then(resolve).catch(resolve);
                }
            });

            preloadCache.set(src, p);
            return p;
        }

        function preloadBatch(start) {
            const promises = [];
            for (let i = 0; i < effectiveBatchSize; i++) {
                const vendor = vendors[(start + i) % vendors.length];
                if (vendor && vendor.logo) promises.push(preloadSrc(vendor.logo));
            }
            return Promise.all(promises);
        }

        function renderBatch(start) {
            for (let i = 0; i < batchSize; i++) {
                const slot = slots[i];
                const img = imgs[i];

                if (i >= effectiveBatchSize) {
                    slot.style.visibility = 'hidden';
                    slot.disabled = true;
                    if (img) {
                        img.removeAttribute('src');
                        img.alt = '';
                    }
                    continue;
                }

                const vendor = vendors[(start + i) % vendors.length];
                slot.style.visibility = 'visible';
                slot.disabled = false;
                slot.dataset.vendorName = vendor.name || '';

                if (img) {
                    const nextSrc = vendor.logo || '';
                    const currentAttrSrc = img.getAttribute('src') || '';
                    if (currentAttrSrc !== nextSrc) img.setAttribute('src', nextSrc);
                    img.alt = vendor.name ? vendor.name + ' logo' : 'Vendor Logo';
                }
            }
        }

        function onClick(e) {
            const btn = e.target && e.target.closest && e.target.closest('[data-our-vendors-slot]');
            if (!btn || !row.contains(btn)) return;
            const vendorName = btn.dataset && btn.dataset.vendorName;
            if (vendorName) goToVendorPage(vendorName);
        }

        function enableUI() {
            if (uiEnabled) return;
            renderBatch(startIndex);
            wrapper.classList.add('our-vendors--enhanced');
            rotator.removeAttribute('aria-hidden');
            row.addEventListener('click', onClick);
            uiEnabled = true;
        }

        function disableUI() {
            if (!uiEnabled) return;
            wrapper.classList.remove('our-vendors--enhanced');
            rotator.setAttribute('aria-hidden', 'true');
            row.classList.remove('is-fading');
            row.removeEventListener('click', onClick);
            uiEnabled = false;
        }

        function stop() {
            tickToken++;
            if (timerId) window.clearInterval(timerId);
            timerId = null;
            inTick = false;
            row.classList.remove('is-fading');
        }

        function tick() {
            if (inTick) return;
            inTick = true;

            const myToken = tickToken;
            const nextIndex = (startIndex + batchSize) % vendors.length;

            if (fadeDuration > 0) row.classList.add('is-fading');

            const waitFade = new Promise((resolve) => window.setTimeout(resolve, fadeDuration));
            const preloadNext = preloadBatch(nextIndex);

            Promise.all([waitFade, preloadNext]).then(() => {
                if (myToken !== tickToken) return;
                startIndex = nextIndex;
                renderBatch(startIndex);
                row.classList.remove('is-fading');
                inTick = false;
            });
        }

        function start() {
            if (!mobileMql.matches) return;
            if (document.hidden) return;
            if (vendors.length <= batchSize) return;
            if (timerId) return;
            timerId = window.setInterval(tick, intervalMs);
        }

        function updateRunning() {
            const shouldEnhance = mobileMql.matches && !document.hidden;

            // Only toggle DOM/UI when the "enhanced" state actually changes.
            if (!shouldEnhance) {
                stop();
                disableUI();
                return;
            }

            enableUI();

            // Only run the interval when in view; otherwise leave UI in place but idle.
            if (!inView) {
                stop();
                return;
            }

            // Preload current + next batch to avoid decode/network work during scroll.
            preloadBatch(startIndex);
            if (vendors.length > batchSize) preloadBatch((startIndex + batchSize) % vendors.length);

            start();
        }

        // Start once on load.
        updateRunning();

        // React to viewport changes instead of binding a hot resize loop.
        const onMqlChange = () => updateRunning();
        if (mobileMql.addEventListener) mobileMql.addEventListener('change', onMqlChange);
        else if (mobileMql.addListener) mobileMql.addListener(onMqlChange);

        document.addEventListener('visibilitychange', updateRunning, { passive: true });

        // Pause when section is not in view.
        if ('IntersectionObserver' in window) {
            const io = new IntersectionObserver((entries) => {
                const entry = entries && entries[0];
                const nextInView = !!(entry && entry.isIntersecting);
                if (nextInView === inView) return;
                inView = nextInView;
                updateRunning();
            }, { root: null, threshold: 0, rootMargin: '200px 0px 200px 0px' });
            io.observe(wrapper);
        }
    })();
</script>